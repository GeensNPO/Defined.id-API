"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const operators_2 = require("rxjs/operators");
const DtoMapping_1 = require("../core/utils/DtoMapping");
const MosaicId_1 = require("../model/mosaic/MosaicId");
const NamespaceId_1 = require("../model/namespace/NamespaceId");
const NamespacePaginationStreamer_1 = require("../infrastructure/paginationStreamer/NamespacePaginationStreamer");
/**
 * Account Service
 */
class AccountService {
    /**
     * Constructor
     * @param repositoryFactory
     */
    constructor(repositoryFactory) {
        this.repositoryFactory = repositoryFactory;
        this.accountRepository = repositoryFactory.createAccountRepository();
        this.namespaceRepository = repositoryFactory.createNamespaceRepository();
    }
    /**
     * Get account info with resolved mosaic
     * @param addresses Array of addresses
     */
    accountInfoWithResolvedMosaic(addresses) {
        const accountInfoObservable = this.accountRepository.getAccountsInfo(addresses);
        const distinctNames = accountInfoObservable.pipe(operators_2.mergeMap((info) => {
            const namespaceIds = this.getDistinctNamespaceIdFromAccountInfos(info);
            if (namespaceIds.length) {
                return this.namespaceRepository.getNamespacesNames(namespaceIds);
            }
            return rxjs_1.of([]);
        }));
        return accountInfoObservable.pipe(operators_1.withLatestFrom(distinctNames), operators_1.map(([infos, names]) => {
            return infos.map((info) => {
                const resolved = this.resolveMosaics(info.mosaics, names);
                return DtoMapping_1.DtoMapping.assign(info, { resolvedMosaics: resolved });
            });
        }));
    }
    /**
     * Get namespace info for account with namespace name
     * @param addresses Namespace owner address
     * @returns {Observable<NamespaceInfoWithName[]>}
     */
    accountNamespacesWithName(address) {
        const steatmer = new NamespacePaginationStreamer_1.NamespacePaginationStreamer(this.namespaceRepository).search({ ownerAddress: address }).pipe(operators_1.toArray());
        return steatmer.pipe(operators_2.mergeMap((infos) => {
            const namespaceIds = infos.map((i) => i.id);
            return this.namespaceRepository.getNamespacesNames(namespaceIds).pipe(operators_1.map((resolved) => {
                return infos.map((info) => {
                    const name = resolved.find((r) => r.namespaceId.equals(info.id));
                    return DtoMapping_1.DtoMapping.assign(info, { namespaceName: name === null || name === void 0 ? void 0 : name.name });
                });
            }));
        }));
    }
    /**
     * Resolve mosaics provided namespace names
     * @param mosaics unresolved mosaics
     * @return {ResolvedMosaic[]}
     */
    resolveMosaics(mosaics, names) {
        return mosaics.map((mosaic) => {
            if (mosaic.id instanceof MosaicId_1.MosaicId) {
                return mosaic;
            }
            else {
                const name = names.find((f) => f.namespaceId.equals(mosaic.id));
                if (name) {
                    return DtoMapping_1.DtoMapping.assign(mosaic, { namespaceName: name });
                }
                else {
                    return mosaic;
                }
            }
        });
    }
    /**
     * Get distinct list of namespaces ids from list of account infos
     * @param accountInfos List of account infos
     * @returns {NamespaceId[]}
     */
    getDistinctNamespaceIdFromAccountInfos(accountInfos) {
        const namespaceIds = [];
        accountInfos.forEach((info) => {
            info.mosaics.forEach((mosaic) => {
                if (mosaic.id instanceof NamespaceId_1.NamespaceId) {
                    if (!namespaceIds.find((n) => n.equals(mosaic.id))) {
                        namespaceIds.push(mosaic.id);
                    }
                }
            });
        });
        return namespaceIds;
    }
}
exports.AccountService = AccountService;
//# sourceMappingURL=AccountService.js.map