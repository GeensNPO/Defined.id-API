"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NemTransactionService = void 0;
const nem2Sdk = require("symbol-sdk");
const __1 = require("..");
const NetworkService_1 = require("./NetworkService");
var PublicAccount = nem2Sdk.PublicAccount;
var TransferTransaction = nem2Sdk.TransferTransaction;
const symbol_sdk_1 = require("symbol-sdk");
const Address = nem2Sdk.Address;
const Deadline = nem2Sdk.Deadline;
const Account = nem2Sdk.Account;
const UInt64 = nem2Sdk.UInt64;
const PlainMessage = nem2Sdk.PlainMessage;
const Mosaic = nem2Sdk.Mosaic;
const MosaicId = nem2Sdk.MosaicId;
const TransactionHttp = nem2Sdk.TransactionHttp;
const AccountHttp = nem2Sdk.AccountHttp;
const XEM = nem2Sdk.NetworkCurrencyLocal;
class NemTransactionService {
    static createTimestampTransaction(nemAccount, hash, nodeUri) {
        return new Promise(async (resolve, reject) => {
            const privateKey = nemAccount.privateKey;
            const address = nemAccount.address;
            const networkType = nemAccount.networkType;
            if (networkType && address && privateKey) {
                let transferTransaction = TransferTransaction.create(Deadline.create(), Address.createFromRawAddress(address), [], PlainMessage.create(hash), networkType, UInt64.fromUint(2000000) // should be a config parameter
                );
                const account = Account.createFromPrivateKey(privateKey, networkType);
                const generationHash = await NetworkService_1.NetworkService.getGenerationHash(nodeUri);
                return resolve(account.sign(transferTransaction, generationHash));
            }
            else {
                return reject('Failed to create timestamp transaction');
            }
        });
    }
    static announceTransaction(signedTransaction, nodeUri) {
        return new Promise(((resolve, reject) => {
            const transactionHttp = new TransactionHttp(nodeUri);
            return transactionHttp.announce(signedTransaction).subscribe(ok => resolve(signedTransaction.hash), err => reject(err));
        }));
    }
    static timestampTransaction(nemAccount, hash, nodeUri) {
        return this.createTimestampTransaction(nemAccount, hash, nodeUri).then((signedTransaction) => {
            return this.announceTransaction(signedTransaction, nodeUri);
        });
    }
    static getTransactionIndexForHash(pubKey, hash, nodeUri, blockchain) {
        const networkType = __1.Blockchain.getNetworkTypeByBlockchain(blockchain);
        if (networkType) {
            const account = PublicAccount.createFromPublicKey(pubKey, networkType);
            return this.getTransactionIndexForHashAndAccount(account, hash, nodeUri);
        }
        else {
            return Promise.reject("NetworkType is undefined");
        }
    }
    //Lookup the documentHash in the blockchain, by retrieving the outgoing transactions for "account" and check if the documentHash is registered in this transaction somewhere
    //Return the index of the transaction that contains this. (0 is the latest transaction)
    static getTransactionIndexForHashAndAccount(account, hash, nodeUri) {
        //Extract the timestamps which are in the payload
        return new Promise((resolve, reject) => {
            const repositoryFactory = new symbol_sdk_1.RepositoryFactoryHttp(nodeUri);
            const transactionHttp = repositoryFactory.createTransactionRepository();
            const searchCriteria = { group: symbol_sdk_1.TransactionGroup.Confirmed, signerPublicKey: account.publicKey, pageNumber: 1, pageSize: 100, type: [symbol_sdk_1.TransactionType.TRANSFER] };
            transactionHttp
                .search(searchCriteria)
                .subscribe((page) => { return resolve(this.getTransactionIndexForHashAndTxList(hash, page.data)); }, err => reject(err));
        });
    }
    static getRegisteredHashes(account, nodeUri) {
        return new Promise((resolve, reject) => {
            const accountHttp = new AccountHttp(nodeUri);
            const repositoryFactory = new symbol_sdk_1.RepositoryFactoryHttp(nodeUri);
            const transactionHttp = repositoryFactory.createTransactionRepository();
            const searchCriteria = { group: symbol_sdk_1.TransactionGroup.Confirmed, signerPublicKey: account.publicKey, pageNumber: 1, pageSize: 100, type: [symbol_sdk_1.TransactionType.TRANSFER] };
            transactionHttp
                .search(searchCriteria)
                .subscribe(page => {
                return resolve(NemTransactionService.getRegisteredHashesFromTxList(page.data));
            }, err => reject(err));
        });
    }
    static getRegisteredHashesFromTxList(txs) {
        let result = txs.filter(__1.TransactionFilter.transferTransactionSameSenderReceiver)
            .sort(__1.TransactionFilter.sortTransactionsByHeight);
        const hashes = result.map((tx) => {
            const transTx = tx;
            return transTx.message.payload.toLowerCase();
        });
        return hashes;
    }
    static getTransactionIndexForHashAndTxList(hash, txs) {
        const hashes = this.getRegisteredHashesFromTxList(txs);
        return hashes.indexOf(hash.toLowerCase());
    }
}
exports.NemTransactionService = NemTransactionService;
