"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Key = void 0;
const __1 = require("..");
const KeyTypes_1 = require("../enums/KeyTypes");
const nem2Sdk = require("symbol-sdk");
const symbol_hd_wallets_1 = require("symbol-hd-wallets");
const nacl = require('tweetnacl');
const naclUtil = require('tweetnacl-util');
const Account = nem2Sdk.Account;
const NetworkType = nem2Sdk.NetworkType;
class Key {
    constructor(purpose, seed, personaId, connectionId) {
        this.purpose = purpose;
        this.personaId = personaId;
        this.connectionId = connectionId;
        const key = this.generateKey(seed);
        this.secretSeed = key.secretSeed;
        this.publicKey = key.publickey;
        this.privateKey = key.privatekey;
        this.privateKey64 = key.privatekey64;
    }
    generateKey(seed) {
        let derivePath;
        if (this.connectionId)
            derivePath = __1.SecurityService.derivePath(`m/0'/${this.purpose.id}'/${this.personaId}'/${this.connectionId}'`, seed);
        else
            derivePath = __1.SecurityService.derivePath(`m/0'/${this.purpose.id}'/${this.personaId}'`, seed);
        const secretSeed = Buffer.from(derivePath.key);
        switch (this.purpose.type) {
            case KeyTypes_1.KeyTypes.NEM2Key:
                return this.generateNEM2Key(seed);
            case KeyTypes_1.KeyTypes.Ed25519VerificationKey2018:
            default:
                return this.generateEd25519Key(secretSeed);
        }
    }
    generateEd25519Key(secretSeed) {
        const secretSeedUint8 = new Uint8Array(secretSeed);
        const naclKeys = nacl.sign.keyPair.fromSeed(secretSeedUint8);
        const privateKey64 = Buffer.from(naclKeys.secretKey);
        const privateKey = Buffer.from(naclKeys.secretKey.slice(0, 32));
        let publicKey = Buffer.from(naclKeys.publicKey);
        return {
            publickey: publicKey,
            privatekey: privateKey,
            privatekey64: privateKey64,
            secretSeed: secretSeed,
        };
    }
    generateNEM2Key(words) {
        const mnemonic = new symbol_hd_wallets_1.MnemonicPassPhrase(words);
        const bip32Seed = mnemonic.toSeed();
        const xkey = symbol_hd_wallets_1.ExtendedKey.createFromSeed(bip32Seed.toString('hex'));
        const wallet = new symbol_hd_wallets_1.Wallet(xkey.derivePath('m/44\'/4343\'/0\'/0\'/0\''));
        //Networktype does not matter for public key generation
        //Take note: for address generation, the networkType is important, so don't use this account for anything else than extracting the public and private keys.
        const masterAccount = wallet.getAccount(NetworkType.TEST_NET);
        const privateKey = Buffer.from(masterAccount.privateKey, 'hex');
        const publicKey = Buffer.from(masterAccount.publicKey, 'hex');
        //If length is 33 remove the zero byte from the public key
        let publicKeyRed = publicKey;
        if (publicKeyRed.length === 33)
            publicKeyRed = publicKeyRed.slice(1, 33);
        const concatInput = [privateKey, publicKeyRed];
        const privateKey64 = Buffer.concat(concatInput, 64);
        return {
            publickey: publicKey,
            privatekey: privateKey,
            privatekey64: privateKey64,
            secretSeed: bip32Seed,
        };
    }
}
exports.Key = Key;
/**
 * Default account derivation path
 * @var {string}
*/
Key.DEFAULT_ACCOUNT_PATH_SYMBOL = `m/44'/4343'/0'/0'/0'`;
