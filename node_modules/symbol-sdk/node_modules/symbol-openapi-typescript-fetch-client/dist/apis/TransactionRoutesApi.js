"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class TransactionRoutesApi extends runtime.BaseAPI {
    /**
     * Announces a cosignature transaction to the network.
     * Announce a cosignature transaction
     */
    announceCosignatureTransactionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.cosignature === null || requestParameters.cosignature === undefined) {
                throw new runtime.RequiredError('cosignature', 'Required parameter requestParameters.cosignature was null or undefined when calling announceCosignatureTransaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/transactions/cosignature`,
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.CosignatureToJSON(requestParameters.cosignature),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.AnnounceTransactionInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Announces a cosignature transaction to the network.
     * Announce a cosignature transaction
     */
    announceCosignatureTransaction(cosignature) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.announceCosignatureTransactionRaw({ cosignature: cosignature });
            return yield response.value();
        });
    }
    /**
     * Announces an aggregate bonded transaction to the network.
     * Announce an aggregate bonded transaction
     */
    announcePartialTransactionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionPayload === null || requestParameters.transactionPayload === undefined) {
                throw new runtime.RequiredError('transactionPayload', 'Required parameter requestParameters.transactionPayload was null or undefined when calling announcePartialTransaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/transactions/partial`,
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.TransactionPayloadToJSON(requestParameters.transactionPayload),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.AnnounceTransactionInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Announces an aggregate bonded transaction to the network.
     * Announce an aggregate bonded transaction
     */
    announcePartialTransaction(transactionPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.announcePartialTransactionRaw({ transactionPayload: transactionPayload });
            return yield response.value();
        });
    }
    /**
     * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It\'s recommended to use SDKs instead of calling the API endpoint directly to announce transactions.
     * Announce a new transaction
     */
    announceTransactionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionPayload === null || requestParameters.transactionPayload === undefined) {
                throw new runtime.RequiredError('transactionPayload', 'Required parameter requestParameters.transactionPayload was null or undefined when calling announceTransaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/transactions`,
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.TransactionPayloadToJSON(requestParameters.transactionPayload),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.AnnounceTransactionInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It\'s recommended to use SDKs instead of calling the API endpoint directly to announce transactions.
     * Announce a new transaction
     */
    announceTransaction(transactionPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.announceTransactionRaw({ transactionPayload: transactionPayload });
            return yield response.value();
        });
    }
    /**
     * Returns confirmed transaction information given a transactionId or hash.
     * Get confirmed transaction information
     */
    getConfirmedTransactionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionId === null || requestParameters.transactionId === undefined) {
                throw new runtime.RequiredError('transactionId', 'Required parameter requestParameters.transactionId was null or undefined when calling getConfirmedTransaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/transactions/confirmed/{transactionId}`.replace(`{${"transactionId"}}`, encodeURIComponent(String(requestParameters.transactionId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns confirmed transaction information given a transactionId or hash.
     * Get confirmed transaction information
     */
    getConfirmedTransaction(transactionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getConfirmedTransactionRaw({ transactionId: transactionId });
            return yield response.value();
        });
    }
    /**
     * Returns confirmed transactions information for a given array of transactionIds.
     * Get confirmed trasactions information
     */
    getConfirmedTransactionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionIds === null || requestParameters.transactionIds === undefined) {
                throw new runtime.RequiredError('transactionIds', 'Required parameter requestParameters.transactionIds was null or undefined when calling getConfirmedTransactions.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/transactions/confirmed`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.TransactionIdsToJSON(requestParameters.transactionIds),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.TransactionInfoDTOFromJSON));
        });
    }
    /**
     * Returns confirmed transactions information for a given array of transactionIds.
     * Get confirmed trasactions information
     */
    getConfirmedTransactions(transactionIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getConfirmedTransactionsRaw({ transactionIds: transactionIds });
            return yield response.value();
        });
    }
    /**
     * Returns partial transaction information given a transactionId or hash.
     * Get partial transaction information
     */
    getPartialTransactionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionId === null || requestParameters.transactionId === undefined) {
                throw new runtime.RequiredError('transactionId', 'Required parameter requestParameters.transactionId was null or undefined when calling getPartialTransaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/transactions/partial/{transactionId}`.replace(`{${"transactionId"}}`, encodeURIComponent(String(requestParameters.transactionId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns partial transaction information given a transactionId or hash.
     * Get partial transaction information
     */
    getPartialTransaction(transactionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getPartialTransactionRaw({ transactionId: transactionId });
            return yield response.value();
        });
    }
    /**
     * Returns partial transactions information for a given array of transactionIds.
     * Get partial trasactions information
     */
    getPartialTransactionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionIds === null || requestParameters.transactionIds === undefined) {
                throw new runtime.RequiredError('transactionIds', 'Required parameter requestParameters.transactionIds was null or undefined when calling getPartialTransactions.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/transactions/partial`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.TransactionIdsToJSON(requestParameters.transactionIds),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.TransactionInfoDTOFromJSON));
        });
    }
    /**
     * Returns partial transactions information for a given array of transactionIds.
     * Get partial trasactions information
     */
    getPartialTransactions(transactionIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getPartialTransactionsRaw({ transactionIds: transactionIds });
            return yield response.value();
        });
    }
    /**
     * Returns unconfirmed transaction information given a transactionId or hash.
     * Get unconfirmed transaction information
     */
    getUnconfirmedTransactionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionId === null || requestParameters.transactionId === undefined) {
                throw new runtime.RequiredError('transactionId', 'Required parameter requestParameters.transactionId was null or undefined when calling getUnconfirmedTransaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/transactions/unconfirmed/{transactionId}`.replace(`{${"transactionId"}}`, encodeURIComponent(String(requestParameters.transactionId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns unconfirmed transaction information given a transactionId or hash.
     * Get unconfirmed transaction information
     */
    getUnconfirmedTransaction(transactionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getUnconfirmedTransactionRaw({ transactionId: transactionId });
            return yield response.value();
        });
    }
    /**
     * Returns unconfirmed transactions information for a given array of transactionIds.
     * Get unconfirmed trasactions information
     */
    getUnconfirmedTransactionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionIds === null || requestParameters.transactionIds === undefined) {
                throw new runtime.RequiredError('transactionIds', 'Required parameter requestParameters.transactionIds was null or undefined when calling getUnconfirmedTransactions.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/transactions/unconfirmed`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.TransactionIdsToJSON(requestParameters.transactionIds),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.TransactionInfoDTOFromJSON));
        });
    }
    /**
     * Returns unconfirmed transactions information for a given array of transactionIds.
     * Get unconfirmed trasactions information
     */
    getUnconfirmedTransactions(transactionIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getUnconfirmedTransactionsRaw({ transactionIds: transactionIds });
            return yield response.value();
        });
    }
    /**
     * Returns an array of confirmed transactions.
     * Search confirmed transactions
     */
    searchConfirmedTransactionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.address !== undefined) {
                queryParameters['address'] = requestParameters.address;
            }
            if (requestParameters.recipientAddress !== undefined) {
                queryParameters['recipientAddress'] = requestParameters.recipientAddress;
            }
            if (requestParameters.signerPublicKey !== undefined) {
                queryParameters['signerPublicKey'] = requestParameters.signerPublicKey;
            }
            if (requestParameters.height !== undefined) {
                queryParameters['height'] = requestParameters.height;
            }
            if (requestParameters.type) {
                queryParameters['type'] = requestParameters.type;
            }
            if (requestParameters.embedded !== undefined) {
                queryParameters['embedded'] = requestParameters.embedded;
            }
            if (requestParameters.pageSize !== undefined) {
                queryParameters['pageSize'] = requestParameters.pageSize;
            }
            if (requestParameters.pageNumber !== undefined) {
                queryParameters['pageNumber'] = requestParameters.pageNumber;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.order !== undefined) {
                queryParameters['order'] = requestParameters.order;
            }
            const headerParameters = {};
            const response = yield this.request({
                path: `/transactions/confirmed`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionPageFromJSON(jsonValue));
        });
    }
    /**
     * Returns an array of confirmed transactions.
     * Search confirmed transactions
     */
    searchConfirmedTransactions(address, recipientAddress, signerPublicKey, height, type, embedded, pageSize, pageNumber, offset, order) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchConfirmedTransactionsRaw({ address: address, recipientAddress: recipientAddress, signerPublicKey: signerPublicKey, height: height, type: type, embedded: embedded, pageSize: pageSize, pageNumber: pageNumber, offset: offset, order: order });
            return yield response.value();
        });
    }
    /**
     * Returns an array of partial transactions.
     * Search partial transactions
     */
    searchPartialTransactionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.address !== undefined) {
                queryParameters['address'] = requestParameters.address;
            }
            if (requestParameters.recipientAddress !== undefined) {
                queryParameters['recipientAddress'] = requestParameters.recipientAddress;
            }
            if (requestParameters.signerPublicKey !== undefined) {
                queryParameters['signerPublicKey'] = requestParameters.signerPublicKey;
            }
            if (requestParameters.height !== undefined) {
                queryParameters['height'] = requestParameters.height;
            }
            if (requestParameters.type) {
                queryParameters['type'] = requestParameters.type;
            }
            if (requestParameters.embedded !== undefined) {
                queryParameters['embedded'] = requestParameters.embedded;
            }
            if (requestParameters.pageSize !== undefined) {
                queryParameters['pageSize'] = requestParameters.pageSize;
            }
            if (requestParameters.pageNumber !== undefined) {
                queryParameters['pageNumber'] = requestParameters.pageNumber;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.order !== undefined) {
                queryParameters['order'] = requestParameters.order;
            }
            const headerParameters = {};
            const response = yield this.request({
                path: `/transactions/partial`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionPageFromJSON(jsonValue));
        });
    }
    /**
     * Returns an array of partial transactions.
     * Search partial transactions
     */
    searchPartialTransactions(address, recipientAddress, signerPublicKey, height, type, embedded, pageSize, pageNumber, offset, order) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchPartialTransactionsRaw({ address: address, recipientAddress: recipientAddress, signerPublicKey: signerPublicKey, height: height, type: type, embedded: embedded, pageSize: pageSize, pageNumber: pageNumber, offset: offset, order: order });
            return yield response.value();
        });
    }
    /**
     * Returns an array of unconfirmed transactions.
     * Search unconfirmed transactions
     */
    searchUnconfirmedTransactionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.address !== undefined) {
                queryParameters['address'] = requestParameters.address;
            }
            if (requestParameters.recipientAddress !== undefined) {
                queryParameters['recipientAddress'] = requestParameters.recipientAddress;
            }
            if (requestParameters.signerPublicKey !== undefined) {
                queryParameters['signerPublicKey'] = requestParameters.signerPublicKey;
            }
            if (requestParameters.height !== undefined) {
                queryParameters['height'] = requestParameters.height;
            }
            if (requestParameters.type) {
                queryParameters['type'] = requestParameters.type;
            }
            if (requestParameters.embedded !== undefined) {
                queryParameters['embedded'] = requestParameters.embedded;
            }
            if (requestParameters.pageSize !== undefined) {
                queryParameters['pageSize'] = requestParameters.pageSize;
            }
            if (requestParameters.pageNumber !== undefined) {
                queryParameters['pageNumber'] = requestParameters.pageNumber;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.order !== undefined) {
                queryParameters['order'] = requestParameters.order;
            }
            const headerParameters = {};
            const response = yield this.request({
                path: `/transactions/unconfirmed`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionPageFromJSON(jsonValue));
        });
    }
    /**
     * Returns an array of unconfirmed transactions.
     * Search unconfirmed transactions
     */
    searchUnconfirmedTransactions(address, recipientAddress, signerPublicKey, height, type, embedded, pageSize, pageNumber, offset, order) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchUnconfirmedTransactionsRaw({ address: address, recipientAddress: recipientAddress, signerPublicKey: signerPublicKey, height: height, type: type, embedded: embedded, pageSize: pageSize, pageNumber: pageNumber, offset: offset, order: order });
            return yield response.value();
        });
    }
}
exports.TransactionRoutesApi = TransactionRoutesApi;
