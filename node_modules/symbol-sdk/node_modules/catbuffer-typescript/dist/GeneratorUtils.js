"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorUtils = void 0;
class GeneratorUtils {
    static bufferToUint64(input) {
        if (8 !== input.length) {
            throw Error(`byte array has unexpected size '${input.length}'`);
        }
        input = input.reverse();
        const view = new DataView(input.buffer);
        return [view.getUint32(4), view.getUint32(0)];
    }
    static readUint32At(bytes, index) {
        return ((bytes[index] +
            (bytes[index + 1] << 8) +
            (bytes[index + 2] << 16) +
            (bytes[index + 3] << 24)) >>>
            0);
    }
    static uintToBuffer(uintValue, bufferSize) {
        const buffer = new ArrayBuffer(bufferSize);
        const dataView = new DataView(buffer);
        try {
            if (1 === bufferSize) {
                dataView.setUint8(0, uintValue);
            }
            else if (2 === bufferSize) {
                dataView.setUint16(0, uintValue, true);
            }
            else if (4 === bufferSize) {
                dataView.setUint32(0, uintValue, true);
            }
            else {
                throw new Error("Unexpected bufferSize");
            }
            return new Uint8Array(buffer);
        }
        catch (e) {
            throw new Error(`Converting uint value ${uintValue} into buffer with error: ${e}`);
        }
    }
    static bufferToUint(buffer) {
        const dataView = new DataView(buffer.buffer);
        try {
            if (1 === buffer.byteLength) {
                return dataView.getUint8(0);
            }
            else if (2 === buffer.byteLength) {
                return dataView.getUint16(0, true);
            }
            else if (4 === buffer.byteLength) {
                return dataView.getUint32(0, true);
            }
            throw new Error("Unexpected buffer size");
        }
        catch (e) {
            throw new Error(`Converting buffer into number with error: ${e}`);
        }
    }
    static uint64ToBuffer(uintValue) {
        const uint32Array = new Uint32Array(uintValue);
        return new Uint8Array(uint32Array.buffer);
    }
    static concatTypedArrays(array1, array2) {
        const newArray = new Uint8Array(array1.length + array2.length);
        newArray.set(array1);
        newArray.set(array2, array1.length);
        return newArray;
    }
    static getBytes(binary, size) {
        if (size > binary.length) {
            throw new RangeError();
        }
        const bytes = binary.slice(0, size);
        return bytes;
    }
    static getTransactionPaddingSize(size, alignment) {
        return 0 === size % alignment ? 0 : alignment - (size % alignment);
    }
    static compact(uint64) {
        const low = uint64[0];
        const high = uint64[1];
        if (0x00200000 <= high) {
            return uint64;
        }
        return high * 0x100000000 + low;
    }
    static fromUint(number) {
        const value = [(number & 0xffffffff) >>> 0, (number / 0x100000000) >>> 0];
        return value;
    }
}
exports.GeneratorUtils = GeneratorUtils;
GeneratorUtils.uint8ToInt8 = (input) => {
    if (0xff < input) {
        throw Error(`input '${input}' is out of range`);
    }
    return (input << 24) >> 24;
};
//# sourceMappingURL=GeneratorUtils.js.map