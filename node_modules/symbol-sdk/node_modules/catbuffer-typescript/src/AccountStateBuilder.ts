// tslint:disable: jsdoc-format
/**
*** Copyright (c) 2016-present,
*** Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.
***
*** This file is part of Catapult.
***
*** Catapult is free software: you can redistribute it and/or modify
*** it under the terms of the GNU Lesser General Public License as published by
*** the Free Software Foundation, either version 3 of the License, or
*** (at your option) any later version.
***
*** Catapult is distributed in the hope that it will be useful,
*** but WITHOUT ANY WARRANTY; without even the implied warranty of
*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
*** GNU Lesser General Public License for more details.
***
*** You should have received a copy of the GNU Lesser General Public License
*** along with Catapult. If not, see <http://www.gnu.org/licenses/>.
**/

import { AccountKeyTypeFlagsDto } from './AccountKeyTypeFlagsDto';
import { AccountStateFormatDto } from './AccountStateFormatDto';
import { AccountTypeDto } from './AccountTypeDto';
import { AddressDto } from './AddressDto';
import { GeneratorUtils } from './GeneratorUtils';
import { HeightActivityBucketsBuilder } from './HeightActivityBucketsBuilder';
import { HeightDto } from './HeightDto';
import { ImportanceSnapshotBuilder } from './ImportanceSnapshotBuilder';
import { KeyDto } from './KeyDto';
import { MosaicBuilder } from './MosaicBuilder';
import { PinnedVotingKeyBuilder } from './PinnedVotingKeyBuilder';

/** Binary layout for non-historical account state. */
export class AccountStateBuilder {
    /** Address of account. */
    address: AddressDto;
    /** Height at which address has been obtained. */
    addressHeight: HeightDto;
    /** Public key of account. */
    publicKey: KeyDto;
    /** Height at which public key has been obtained. */
    publicKeyHeight: HeightDto;
    /** Type of account. */
    accountType: AccountTypeDto;
    /** Account format. */
    format: AccountStateFormatDto;
    /** Mask of supplemental public key flags. */
    supplementalPublicKeysMask: AccountKeyTypeFlagsDto;
    /** Linked account public key. */
    linkedPublicKey?: KeyDto;
    /** Node public key. */
    nodePublicKey?: KeyDto;
    /** Vrf public key. */
    vrfPublicKey?: KeyDto;
    /** Voting public keys. */
    votingPublicKeys: PinnedVotingKeyBuilder[];
    /** Current importance snapshot of the account. */
    importanceSnapshots?: ImportanceSnapshotBuilder;
    /** Activity buckets of the account. */
    activityBuckets?: HeightActivityBucketsBuilder;
    /** Balances of account. */
    balances: MosaicBuilder[];

    /**
     * Constructor.
     *
     * @param address Address of account.
     * @param addressHeight Height at which address has been obtained.
     * @param publicKey Public key of account.
     * @param publicKeyHeight Height at which public key has been obtained.
     * @param accountType Type of account.
     * @param supplementalPublicKeysMask Mask of supplemental public key flags.
     * @param linkedPublicKey Linked account public key.
     * @param nodePublicKey Node public key.
     * @param vrfPublicKey Vrf public key.
     * @param votingPublicKeys Voting public keys.
     * @param importanceSnapshots Current importance snapshot of the account.
     * @param activityBuckets Activity buckets of the account.
     * @param balances Balances of account.
     */
    // tslint:disable-next-line: max-line-length
    public constructor(address: AddressDto,  addressHeight: HeightDto,  publicKey: KeyDto,  publicKeyHeight: HeightDto,  accountType: AccountTypeDto,  supplementalPublicKeysMask: AccountKeyTypeFlagsDto,  votingPublicKeys: PinnedVotingKeyBuilder[],  balances: MosaicBuilder[],  linkedPublicKey?: KeyDto,  nodePublicKey?: KeyDto,  vrfPublicKey?: KeyDto,  importanceSnapshots?: ImportanceSnapshotBuilder,  activityBuckets?: HeightActivityBucketsBuilder) {
        this.address = address;
        this.addressHeight = addressHeight;
        this.publicKey = publicKey;
        this.publicKeyHeight = publicKeyHeight;
        this.accountType = accountType;
        this.supplementalPublicKeysMask = supplementalPublicKeysMask;
        this.linkedPublicKey = linkedPublicKey;
        this.nodePublicKey = nodePublicKey;
        this.vrfPublicKey = vrfPublicKey;
        this.votingPublicKeys = votingPublicKeys;
        this.importanceSnapshots = importanceSnapshots;
        this.activityBuckets = activityBuckets;
        this.balances = balances;
        if (importanceSnapshots) {
            this.format = AccountStateFormatDto.HIGH_VALUE;
        }
        else {
            this.format = AccountStateFormatDto.HIGH_VALUE;
        }
    }

    /**
     * Creates an instance of AccountStateBuilder from binary payload.
     *
     * @param payload Byte payload to use to serialize the object.
     * @return Instance of AccountStateBuilder.
     */
    public static loadFromBinary(payload: Uint8Array): AccountStateBuilder {
        const byteArray = Array.from(payload);
        const address = AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, address.getSize());
        const addressHeight = HeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, addressHeight.getSize());
        const publicKey = KeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, publicKey.getSize());
        const publicKeyHeight = HeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, publicKeyHeight.getSize());
        const accountType = GeneratorUtils.bufferToUint(GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const format = GeneratorUtils.bufferToUint(GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const supplementalPublicKeysMask = GeneratorUtils.bufferToUint(GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const votingPublicKeysCount = GeneratorUtils.bufferToUint(GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const supplementalPublicKeysMaskConditionBytes = Uint8Array.from(byteArray.slice(0, 32));
        byteArray.splice(0, 32);
        const votingPublicKeys: PinnedVotingKeyBuilder[] = [];
        // tslint:disable-next-line: max-line-length
        for (let i = 0; i < (Array.isArray(votingPublicKeysCount) ? GeneratorUtils.compact(votingPublicKeysCount) : votingPublicKeysCount); i++) {
            const item = PinnedVotingKeyBuilder.loadFromBinary(Uint8Array.from(byteArray));
            votingPublicKeys.push(item);
            byteArray.splice(0, item.getSize());
        }
        const formatConditionBytes = Uint8Array.from(byteArray.slice(0, 1));
        byteArray.splice(0, 1);
        const balancesCount = GeneratorUtils.bufferToUint(GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const balances: MosaicBuilder[] = [];
        for (let i = 0; i < (Array.isArray(balancesCount) ? GeneratorUtils.compact(balancesCount) : balancesCount); i++) {
            const item = MosaicBuilder.loadFromBinary(Uint8Array.from(byteArray));
            balances.push(item);
            byteArray.splice(0, item.getSize());
        }
        let linkedPublicKey;
        if (supplementalPublicKeysMask & AccountKeyTypeFlagsDto.LINKED) {
            linkedPublicKey = KeyDto.loadFromBinary(supplementalPublicKeysMaskConditionBytes);
        }
        let nodePublicKey;
        if (supplementalPublicKeysMask & AccountKeyTypeFlagsDto.NODE) {
            nodePublicKey = KeyDto.loadFromBinary(supplementalPublicKeysMaskConditionBytes);
        }
        let vrfPublicKey;
        if (supplementalPublicKeysMask & AccountKeyTypeFlagsDto.VRF) {
            vrfPublicKey = KeyDto.loadFromBinary(supplementalPublicKeysMaskConditionBytes);
        }
        let importanceSnapshots;
        if (format === AccountStateFormatDto.HIGH_VALUE) {
            importanceSnapshots = ImportanceSnapshotBuilder.loadFromBinary(formatConditionBytes);
        }
        let activityBuckets;
        if (format === AccountStateFormatDto.HIGH_VALUE) {
            activityBuckets = HeightActivityBucketsBuilder.loadFromBinary(formatConditionBytes);
        }
        // tslint:disable-next-line: max-line-length
        return new AccountStateBuilder(address, addressHeight, publicKey, publicKeyHeight, accountType, supplementalPublicKeysMask, votingPublicKeys, balances, linkedPublicKey, nodePublicKey, vrfPublicKey, importanceSnapshots, activityBuckets);
    }

    /**
     * Gets address of account.
     *
     * @return Address of account.
     */
    public getAddress(): AddressDto {
        return this.address;
    }

    /**
     * Gets height at which address has been obtained.
     *
     * @return Height at which address has been obtained.
     */
    public getAddressHeight(): HeightDto {
        return this.addressHeight;
    }

    /**
     * Gets public key of account.
     *
     * @return Public key of account.
     */
    public getPublicKey(): KeyDto {
        return this.publicKey;
    }

    /**
     * Gets height at which public key has been obtained.
     *
     * @return Height at which public key has been obtained.
     */
    public getPublicKeyHeight(): HeightDto {
        return this.publicKeyHeight;
    }

    /**
     * Gets type of account.
     *
     * @return Type of account.
     */
    public getAccountType(): AccountTypeDto {
        return this.accountType;
    }

    /**
     * Gets account format.
     *
     * @return Account format.
     */
    public getFormat(): AccountStateFormatDto {
        return this.format;
    }

    /**
     * Gets mask of supplemental public key flags.
     *
     * @return Mask of supplemental public key flags.
     */
    public getSupplementalPublicKeysMask(): AccountKeyTypeFlagsDto {
        return this.supplementalPublicKeysMask;
    }

    /**
     * Gets linked account public key.
     *
     * @return Linked account public key.
     */
    public getLinkedPublicKey(): KeyDto | undefined {
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto.LINKED) {
            throw new Error('supplementalPublicKeysMask is not set to LINKED.');
        }
        return this.linkedPublicKey;
    }

    /**
     * Gets node public key.
     *
     * @return Node public key.
     */
    public getNodePublicKey(): KeyDto | undefined {
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto.NODE) {
            throw new Error('supplementalPublicKeysMask is not set to NODE.');
        }
        return this.nodePublicKey;
    }

    /**
     * Gets vrf public key.
     *
     * @return Vrf public key.
     */
    public getVrfPublicKey(): KeyDto | undefined {
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto.VRF) {
            throw new Error('supplementalPublicKeysMask is not set to VRF.');
        }
        return this.vrfPublicKey;
    }

    /**
     * Gets voting public keys.
     *
     * @return Voting public keys.
     */
    public getVotingPublicKeys(): PinnedVotingKeyBuilder[] {
        return this.votingPublicKeys;
    }

    /**
     * Gets current importance snapshot of the account.
     *
     * @return Current importance snapshot of the account.
     */
    public getImportanceSnapshots(): ImportanceSnapshotBuilder | undefined {
        if (this.format !== AccountStateFormatDto.HIGH_VALUE) {
            throw new Error('format is not set to HIGH_VALUE.');
        }
        return this.importanceSnapshots;
    }

    /**
     * Gets activity buckets of the account.
     *
     * @return Activity buckets of the account.
     */
    public getActivityBuckets(): HeightActivityBucketsBuilder | undefined {
        if (this.format !== AccountStateFormatDto.HIGH_VALUE) {
            throw new Error('format is not set to HIGH_VALUE.');
        }
        return this.activityBuckets;
    }

    /**
     * Gets balances of account.
     *
     * @return Balances of account.
     */
    public getBalances(): MosaicBuilder[] {
        return this.balances;
    }

    /**
     * Gets the size of the object.
     *
     * @return Size in bytes.
     */
    public getSize(): number {
        let size = 0;
        size += this.address.getSize();
        size += this.addressHeight.getSize();
        size += this.publicKey.getSize();
        size += this.publicKeyHeight.getSize();
        size += 1; // accountType
        size += 1; // format
        size += 1; // supplementalPublicKeysMask
        size += 1; // votingPublicKeysCount
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto.LINKED) {
            size += this.linkedPublicKey!.getSize();
        }
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto.NODE) {
            size += this.nodePublicKey!.getSize();
        }
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto.VRF) {
            size += this.vrfPublicKey!.getSize();
        }
        this.votingPublicKeys.forEach((o) => size += o.getSize());
        if (this.format === AccountStateFormatDto.HIGH_VALUE) {
            size += this.importanceSnapshots!.getSize();
        }
        if (this.format === AccountStateFormatDto.HIGH_VALUE) {
            size += this.activityBuckets!.getSize();
        }
        size += 2; // balancesCount
        this.balances.forEach((o) => size += o.getSize());
        return size;
    }

    /**
     * Serializes an object to bytes.
     *
     * @return Serialized bytes.
     */
    public serialize(): Uint8Array {
        let newArray = Uint8Array.from([]);
        const addressBytes = this.address.serialize();
        newArray = GeneratorUtils.concatTypedArrays(newArray, addressBytes);
        const addressHeightBytes = this.addressHeight.serialize();
        newArray = GeneratorUtils.concatTypedArrays(newArray, addressHeightBytes);
        const publicKeyBytes = this.publicKey.serialize();
        newArray = GeneratorUtils.concatTypedArrays(newArray, publicKeyBytes);
        const publicKeyHeightBytes = this.publicKeyHeight.serialize();
        newArray = GeneratorUtils.concatTypedArrays(newArray, publicKeyHeightBytes);
        const accountTypeBytes = GeneratorUtils.uintToBuffer(this.accountType, 1);
        newArray = GeneratorUtils.concatTypedArrays(newArray, accountTypeBytes);
        const formatBytes = GeneratorUtils.uintToBuffer(this.format, 1);
        newArray = GeneratorUtils.concatTypedArrays(newArray, formatBytes);
        const supplementalPublicKeysMaskBytes = GeneratorUtils.uintToBuffer(this.getSupplementalPublicKeysMask(), 1);
        newArray = GeneratorUtils.concatTypedArrays(newArray, supplementalPublicKeysMaskBytes);
        const votingPublicKeysCountBytes = GeneratorUtils.uintToBuffer(this.votingPublicKeys.length, 1);
        newArray = GeneratorUtils.concatTypedArrays(newArray, votingPublicKeysCountBytes);
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto.LINKED) {
            const linkedPublicKeyBytes = this.linkedPublicKey!.serialize();
            newArray = GeneratorUtils.concatTypedArrays(newArray, linkedPublicKeyBytes);
        }
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto.NODE) {
            const nodePublicKeyBytes = this.nodePublicKey!.serialize();
            newArray = GeneratorUtils.concatTypedArrays(newArray, nodePublicKeyBytes);
        }
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto.VRF) {
            const vrfPublicKeyBytes = this.vrfPublicKey!.serialize();
            newArray = GeneratorUtils.concatTypedArrays(newArray, vrfPublicKeyBytes);
        }
        this.votingPublicKeys.forEach((item) => {
            const votingPublicKeysBytes = item.serialize();
            newArray = GeneratorUtils.concatTypedArrays(newArray, votingPublicKeysBytes);
        });
        if (this.format === AccountStateFormatDto.HIGH_VALUE) {
            const importanceSnapshotsBytes = this.importanceSnapshots!.serialize();
            newArray = GeneratorUtils.concatTypedArrays(newArray, importanceSnapshotsBytes);
        }
        if (this.format === AccountStateFormatDto.HIGH_VALUE) {
            const activityBucketsBytes = this.activityBuckets!.serialize();
            newArray = GeneratorUtils.concatTypedArrays(newArray, activityBucketsBytes);
        }
        const balancesCountBytes = GeneratorUtils.uintToBuffer(this.balances.length, 2);
        newArray = GeneratorUtils.concatTypedArrays(newArray, balancesCountBytes);
        this.balances.forEach((item) => {
            const balancesBytes = item.serialize();
            newArray = GeneratorUtils.concatTypedArrays(newArray, balancesBytes);
        });
        return newArray;
    }
}
