"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const Address_1 = require("../model/account/Address");
const MosaicId_1 = require("../model/mosaic/MosaicId");
const MosaicRestrictionType_1 = require("../model/restriction/MosaicRestrictionType");
const MosaicAddressRestrictionTransaction_1 = require("../model/transaction/MosaicAddressRestrictionTransaction");
const MosaicGlobalRestrictionTransaction_1 = require("../model/transaction/MosaicGlobalRestrictionTransaction");
const UInt64_1 = require("../model/UInt64");
/**
 * MosaicRestrictionTransactionService service
 */
class MosaicRestrictionTransactionService {
    /**
     * Constructor
     * @param restrictionMosaicRepository
     * @param namespaceRepository
     */
    constructor(restrictionMosaicRepository, namespaceRepository) {
        this.restrictionMosaicRepository = restrictionMosaicRepository;
        this.namespaceRepository = namespaceRepository;
        this.defaultMosaicAddressRestrictionValue = UInt64_1.UInt64.fromHex('FFFFFFFFFFFFFFFF');
        this.defaultMosaicGlobalRestrictionValue = UInt64_1.UInt64.fromUint(0);
    }
    /**
     * Create a MosaicGlobalRestrictionTransaction object without previous restriction data
     * @param deadline - Deadline
     * @param networkType - Network identifier
     * @param mosaicId - Unresolved mosaicId
     * @param restrictionKey - Restriction key
     * @param restrictionValue - New restriction value
     * @param restrictionType - New restriction type
     * @param referenceMosaicId - Reference mosaic Id
     * @param maxFee - Max fee
     */
    createMosaicGlobalRestrictionTransaction(deadline, networkType, mosaicId, restrictionKey, restrictionValue, restrictionType, referenceMosaicId = new MosaicId_1.MosaicId(UInt64_1.UInt64.fromUint(0).toDTO()), maxFee = new UInt64_1.UInt64([0, 0])) {
        this.validateInput(restrictionValue);
        return this.getResolvedMosaicId(mosaicId).pipe(operators_1.mergeMap((resolvedMosaicId) => this.getGlobalRestrictionEntry(resolvedMosaicId, restrictionKey).pipe(operators_1.map((restrictionEntry) => {
            const currentValue = restrictionEntry
                ? UInt64_1.UInt64.fromNumericString(restrictionEntry.restrictionValue)
                : this.defaultMosaicGlobalRestrictionValue;
            const currentType = restrictionEntry ? restrictionEntry.restrictionType : MosaicRestrictionType_1.MosaicRestrictionType.NONE;
            return MosaicGlobalRestrictionTransaction_1.MosaicGlobalRestrictionTransaction.create(deadline, resolvedMosaicId, restrictionKey, currentValue, currentType, UInt64_1.UInt64.fromNumericString(restrictionValue), restrictionType, networkType, referenceMosaicId, maxFee);
        }))));
    }
    /**
     * Create a MosaicAddressRestrictionTransaction object without previous restriction data
     * @param deadline - Deadline
     * @param networkType - Network identifier
     * @param mosaicId - Unresolved mosaicId
     * @param restrictionKey - Restriction key
     * @param targetAddress - Unresolved target address
     * @param restrictionValue - New restriction value
     * @param maxFee - Max fee
     */
    createMosaicAddressRestrictionTransaction(deadline, networkType, mosaicId, restrictionKey, targetAddress, restrictionValue, maxFee = new UInt64_1.UInt64([0, 0])) {
        this.validateInput(restrictionValue);
        const combinedUnresolved = rxjs_1.combineLatest(this.getResolvedMosaicId(mosaicId), this.getResolvedAddress(targetAddress));
        return combinedUnresolved.pipe(operators_1.mergeMap(([resolvedMosaicId, resolvedAddress]) => this.getGlobalRestrictionEntry(resolvedMosaicId, restrictionKey).pipe(operators_1.mergeMap((restrictionEntry) => {
            if (!restrictionEntry) {
                throw new Error('Global restriction is not valid for RestrictionKey: ' + restrictionKey);
            }
            return this.getAddressRestrictionEntry(resolvedMosaicId, restrictionKey, resolvedAddress).pipe(operators_1.map((optionalValue) => {
                const currentValue = optionalValue
                    ? UInt64_1.UInt64.fromNumericString(optionalValue)
                    : this.defaultMosaicAddressRestrictionValue;
                return MosaicAddressRestrictionTransaction_1.MosaicAddressRestrictionTransaction.create(deadline, mosaicId, restrictionKey, targetAddress, UInt64_1.UInt64.fromNumericString(restrictionValue), networkType, currentValue, maxFee);
            }));
        }))));
    }
    /**
     * Get address global restriction previous value and type
     * @param mosaicId - Mosaic identifier
     * @param restrictionKey - Mosaic global restriction key
     * @param targetAddress - The target address
     * @return {Observable<string | undefined>}
     */
    getAddressRestrictionEntry(mosaicId, restrictionKey, targetAddress) {
        return this.restrictionMosaicRepository.getMosaicAddressRestriction(mosaicId, targetAddress).pipe(operators_1.map((mosaicRestriction) => {
            return mosaicRestriction.restrictions.get(restrictionKey.toString());
        }), operators_1.catchError((err) => {
            const error = JSON.parse(err.message);
            if (error && error.statusCode && error.statusCode === 404) {
                return rxjs_1.of(undefined);
            }
            throw new Error(err.message);
        }));
    }
    /**
     * Get mosaic global restriction prvious value and type
     * @param mosaicId - Mosaic identifier
     * @param restrictionKey - Mosaic global restriction key
     * @return {Observable<MosaicGlobalRestrictionItem | undefined>}
     */
    getGlobalRestrictionEntry(mosaicId, restrictionKey) {
        return this.restrictionMosaicRepository.getMosaicGlobalRestriction(mosaicId).pipe(operators_1.map((mosaicRestriction) => {
            return mosaicRestriction.restrictions.get(restrictionKey.toString());
        }), operators_1.catchError((err) => {
            const error = JSON.parse(err.message);
            if (error && error.statusCode && error.statusCode === 404) {
                return rxjs_1.of(undefined);
            }
            throw new Error(err.message);
        }));
    }
    /**
     * Check if input restriction key and value are invalid or not
     * @param value - Restriction value
     */
    validateInput(value) {
        if (!UInt64_1.UInt64.isLongNumericString(value)) {
            throw new Error(`RestrictionValue: ${value} is not a valid numeric string.`);
        }
    }
    /**
     * @internal
     * Get resolved mosaicId from namespace repository
     * @param unresolvedMosaicId unresolved mosaicId
     * @returns {MosaicId}
     */
    getResolvedMosaicId(unresolvedMosaicId) {
        if (unresolvedMosaicId instanceof MosaicId_1.MosaicId) {
            return rxjs_1.of(unresolvedMosaicId);
        }
        return this.namespaceRepository.getLinkedMosaicId(unresolvedMosaicId).pipe(operators_1.map((mosaicId) => {
            if (!mosaicId) {
                throw new Error(`Invalid unresolvedMosaicId: ${unresolvedMosaicId.toHex()}`);
            }
            return mosaicId;
        }), operators_1.catchError((err) => {
            throw new Error(err);
        }));
    }
    /**
     * @internal
     * Get resolved address from namespace repository
     * @param unresolvedAddress unresolved address
     * @returns {Address}
     */
    getResolvedAddress(unresolvedAddress) {
        if (unresolvedAddress instanceof Address_1.Address) {
            return rxjs_1.of(unresolvedAddress);
        }
        return this.namespaceRepository.getLinkedAddress(unresolvedAddress).pipe(operators_1.map((address) => {
            if (!address) {
                throw new Error(`Invalid unresolvedAddress: ${unresolvedAddress.toHex()}`);
            }
            return address;
        }), operators_1.catchError((err) => {
            throw new Error(err);
        }));
    }
}
exports.MosaicRestrictionTransactionService = MosaicRestrictionTransactionService;
//# sourceMappingURL=MosaicRestrictionTransactionService.js.map