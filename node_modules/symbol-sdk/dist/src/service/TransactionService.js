"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const NamespaceId_1 = require("../model/namespace/NamespaceId");
const TransactionStatusError_1 = require("../model/transaction/TransactionStatusError");
const TransactionType_1 = require("../model/transaction/TransactionType");
const TransactionGroup_1 = require("../infrastructure/TransactionGroup");
const ReceiptPaginationStreamer_1 = require("../infrastructure/paginationStreamer/ReceiptPaginationStreamer");
const Statement_1 = require("../model/receipt/Statement");
const rxjs_2 = require("rxjs");
/**
 * Transaction Service
 */
class TransactionService {
    /**
     * Constructor
     * @param transactionRepository
     * @param receiptRepository
     */
    constructor(transactionRepository, receiptRepository) {
        this.transactionRepository = transactionRepository;
        this.receiptRepository = receiptRepository;
    }
    /**
     * Resolve unresolved mosaic / address from array of transactions
     * @param transationHashes List of transaction hashes.
     * @returns Observable<Transaction[]>
     */
    resolveAliases(transationHashes) {
        return this.transactionRepository.getTransactionsById(transationHashes, TransactionGroup_1.TransactionGroup.Confirmed).pipe(operators_1.mergeMap((_) => {
            return _;
        }), operators_1.mergeMap((transaction) => this.resolveTransaction(transaction)), operators_1.toArray());
    }
    /**
     * @param signedTransaction Signed transaction to be announced.
     * @param listener Websocket listener
     * @returns {Observable<Transaction>}
     */
    announce(signedTransaction, listener) {
        const signerAddress = signedTransaction.getSignerAddress();
        this.transactionRepository.announce(signedTransaction);
        return this.getTransactionOrRaiseError(listener, signerAddress, signedTransaction.hash, listener.confirmed(signerAddress, signedTransaction.hash));
    }
    /**
     * Announce aggregate transaction
     * **NOTE** A lock fund transaction for this aggregate bonded should exists
     * @param signedTransaction Signed aggregate bonded transaction.
     * @param listener Websocket listener
     * @returns {Observable<AggregateTransaction>}
     */
    announceAggregateBonded(signedTransaction, listener) {
        const signerAddress = signedTransaction.getSignerAddress();
        const transactionObservable = this.transactionRepository
            .announceAggregateBonded(signedTransaction)
            .pipe(operators_1.flatMap(() => listener.aggregateBondedAdded(signerAddress, signedTransaction.hash)));
        return this.getTransactionOrRaiseError(listener, signerAddress, signedTransaction.hash, transactionObservable);
    }
    /**
     * This method announces an a hash lock transaction followed by a aggregate bonded transaction
     * while waiting for being confirmed by listing to the /confirmed and /aggregateBondedAdded web
     * socket. If an error is sent while processing any of the given transaction an Error is raised.
     *
     * @param signedHashLockTransaction Signed hash lock transaction.
     * @param signedAggregateTransaction Signed aggregate bonded transaction.
     * @param listener Websocket listener
     * @returns {Observable<AggregateTransaction>}
     */
    announceHashLockAggregateBonded(signedHashLockTransaction, signedAggregateTransaction, listener) {
        return this.announce(signedHashLockTransaction, listener).pipe(operators_1.flatMap(() => this.announceAggregateBonded(signedAggregateTransaction, listener)));
    }
    /**
     * @internal
     *
     * This method publishes an error if the listener receives an error code for the given address & transaction hash.
     * Otherwise, it returns the passed transactionObservable
     *
     * @param listener the listener.
     * @param address the signer address
     * @param transactionHash the transaction hash
     * @param transactionObservable the observable with the valid transaction
     */
    getTransactionOrRaiseError(listener, address, transactionHash, transactionObservable) {
        const errorObservable = listener.status(address, transactionHash);
        return rxjs_1.merge(transactionObservable, errorObservable).pipe(operators_1.first(), operators_1.map((errorOrTransaction) => {
            if (errorOrTransaction instanceof TransactionStatusError_1.TransactionStatusError) {
                throw new Error(errorOrTransaction.code);
            }
            else {
                return errorOrTransaction;
            }
        }));
    }
    /**
     * Resolve transaction alias(s)
     * @param transaction Transaction to be resolved
     * @returns {Observable<Transaction>}
     */
    resolveTransaction(transaction) {
        if ([TransactionType_1.TransactionType.AGGREGATE_BONDED, TransactionType_1.TransactionType.AGGREGATE_COMPLETE].includes(transaction.type)) {
            if (transaction.innerTransactions.find((tx) => this.checkShouldResolve(tx))) {
                return this.resolvedFromReceipt(transaction, transaction.transactionInfo.index);
            }
            return rxjs_1.of(transaction);
        }
        return this.checkShouldResolve(transaction) ? this.resolvedFromReceipt(transaction, 0) : rxjs_1.of(transaction);
    }
    /**
     * @internal
     * Check if receiptRepository needs to be called to resolve transaction alias
     * @param transaction Transaction
     * @return {boolean}
     */
    checkShouldResolve(transaction) {
        switch (transaction.type) {
            case TransactionType_1.TransactionType.ACCOUNT_KEY_LINK:
            case TransactionType_1.TransactionType.ACCOUNT_METADATA:
            case TransactionType_1.TransactionType.ACCOUNT_OPERATION_RESTRICTION:
            case TransactionType_1.TransactionType.ADDRESS_ALIAS:
            case TransactionType_1.TransactionType.MOSAIC_ALIAS:
            case TransactionType_1.TransactionType.MOSAIC_DEFINITION:
            case TransactionType_1.TransactionType.MULTISIG_ACCOUNT_MODIFICATION:
            case TransactionType_1.TransactionType.NAMESPACE_METADATA:
            case TransactionType_1.TransactionType.NAMESPACE_REGISTRATION:
                return false;
            case TransactionType_1.TransactionType.ACCOUNT_ADDRESS_RESTRICTION:
                const accountAddressRestriction = transaction;
                return (accountAddressRestriction.restrictionAdditions.find((address) => address instanceof NamespaceId_1.NamespaceId) !== undefined ||
                    accountAddressRestriction.restrictionDeletions.find((address) => address instanceof NamespaceId_1.NamespaceId) !== undefined);
            case TransactionType_1.TransactionType.ACCOUNT_MOSAIC_RESTRICTION:
                const accountMosaicRestriction = transaction;
                return (accountMosaicRestriction.restrictionAdditions.find((mosaicId) => mosaicId instanceof NamespaceId_1.NamespaceId) !== undefined ||
                    accountMosaicRestriction.restrictionDeletions.find((mosaicId) => mosaicId instanceof NamespaceId_1.NamespaceId) !== undefined);
            case TransactionType_1.TransactionType.HASH_LOCK:
                return transaction.mosaic.id instanceof NamespaceId_1.NamespaceId;
            case TransactionType_1.TransactionType.MOSAIC_ADDRESS_RESTRICTION:
                const mosaicAddressRestriction = transaction;
                return (mosaicAddressRestriction.targetAddress instanceof NamespaceId_1.NamespaceId ||
                    mosaicAddressRestriction.mosaicId instanceof NamespaceId_1.NamespaceId);
            case TransactionType_1.TransactionType.MOSAIC_GLOBAL_RESTRICTION:
                const mosaicGlobalRestriction = transaction;
                return (mosaicGlobalRestriction.referenceMosaicId instanceof NamespaceId_1.NamespaceId ||
                    mosaicGlobalRestriction.mosaicId instanceof NamespaceId_1.NamespaceId);
            case TransactionType_1.TransactionType.MOSAIC_METADATA:
                return transaction.targetMosaicId instanceof NamespaceId_1.NamespaceId;
            case TransactionType_1.TransactionType.MOSAIC_SUPPLY_CHANGE:
                return transaction.mosaicId instanceof NamespaceId_1.NamespaceId;
            case TransactionType_1.TransactionType.SECRET_PROOF:
                return transaction.recipientAddress instanceof NamespaceId_1.NamespaceId;
            case TransactionType_1.TransactionType.SECRET_LOCK:
                const secretLock = transaction;
                return secretLock.recipientAddress instanceof NamespaceId_1.NamespaceId || secretLock.mosaic.id instanceof NamespaceId_1.NamespaceId;
            case TransactionType_1.TransactionType.TRANSFER:
                const transfer = transaction;
                return (transfer.recipientAddress instanceof NamespaceId_1.NamespaceId ||
                    transfer.mosaics.find((mosaic) => mosaic.id instanceof NamespaceId_1.NamespaceId) !== undefined);
            default:
                throw new Error('Transaction type not not recogonised.');
        }
    }
    /**
     * @internal
     * Resolve transaction alais(s) from block receipt by calling receiptRepository
     * @param transaction Transaction to be resolved
     * @param aggregateIndex Aggregate transaction index
     * @return {Observable<Transaction>}
     */
    resolvedFromReceipt(transaction, aggregateIndex) {
        const addressResolution = ReceiptPaginationStreamer_1.ReceiptPaginationStreamer.addressResolutionStatements(this.receiptRepository)
            .search({ height: transaction.transactionInfo.height })
            .pipe(operators_1.toArray());
        const mosaicResolution = ReceiptPaginationStreamer_1.ReceiptPaginationStreamer.mosaicResolutionStatements(this.receiptRepository)
            .search({ height: transaction.transactionInfo.height })
            .pipe(operators_1.toArray());
        return rxjs_2.combineLatest(mosaicResolution, addressResolution)
            .pipe(operators_1.map(([mosaic, address]) => {
            return new Statement_1.Statement([], address, mosaic);
        }))
            .pipe(operators_1.map((statement) => transaction.resolveAliases(statement, aggregateIndex)));
    }
}
exports.TransactionService = TransactionService;
//# sourceMappingURL=TransactionService.js.map