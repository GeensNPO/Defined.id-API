import { Observable } from 'rxjs';
import { Address } from '../model/account/Address';
import { NewBlock } from '../model/blockchain/NewBlock';
import { AggregateTransaction } from '../model/transaction/AggregateTransaction';
import { CosignatureSignedTransaction } from '../model/transaction/CosignatureSignedTransaction';
import { Transaction } from '../model/transaction/Transaction';
import { TransactionStatusError } from '../model/transaction/TransactionStatusError';
import { IListener } from './IListener';
import { NamespaceRepository } from './NamespaceRepository';
export declare enum ListenerChannelName {
    block = "block",
    confirmedAdded = "confirmedAdded",
    unconfirmedAdded = "unconfirmedAdded",
    unconfirmedRemoved = "unconfirmedRemoved",
    partialAdded = "partialAdded",
    partialRemoved = "partialRemoved",
    cosignature = "cosignature",
    modifyMultisigAccount = "modifyMultisigAccount",
    status = "status"
}
/**
 * Listener service
 */
export declare class Listener implements IListener {
    /**
     * Listener websocket server url. default: rest-gateway's url with ''/ws'' suffix. (e.g. http://localhost:3000/ws)
     */
    readonly url: string;
    /**
     * Namespace repository for resolving account alias
     */
    private namespaceRepository;
    /**
     * WebSocket injected when using listeners in client.
     */
    private websocketInjected?;
    /**
     * Constructor
     * @param url - Listener websocket server url. default: rest-gateway's url with ''/ws'' suffix. (e.g. http://localhost:3000/ws).
     * @param namespaceRepository - NamespaceRepository interface for resolving alias.
     * @param websocketInjected - (Optional) WebSocket injected when using listeners in client.
     */
    constructor(
    /**
     * Listener websocket server url. default: rest-gateway's url with ''/ws'' suffix. (e.g. http://localhost:3000/ws)
     */
    url: string, 
    /**
     * Namespace repository for resolving account alias
     */
    namespaceRepository: NamespaceRepository, 
    /**
     * WebSocket injected when using listeners in client.
     */
    websocketInjected?: any);
    /**
     * Open web socket connection.
     * @returns Promise<Void>
     */
    open(): Promise<void>;
    /**
     * returns a boolean that repressents the open state
     * @returns a boolean
     */
    isOpen(): boolean;
    /**
     * Close web socket connection.
     * @returns void
     */
    close(): void;
    /**
     * Returns an observable stream of BlockInfo.
     * Each time a new Block is added into the blockchain,
     * it emits a new BlockInfo in the event stream.
     *
     * @return an observable stream of BlockInfo
     */
    newBlock(): Observable<NewBlock>;
    /**
     * Returns an observable stream of Transaction for a specific address.
     * Each time a transaction is in confirmed state an it involves the address,
     * it emits a new Transaction in the event stream.
     *
     * @param address address we listen when a transaction is in confirmed state
     * @param transactionHash transactionHash for filtering multiple transactions
     * @return an observable stream of Transaction with state confirmed
     */
    confirmed(address: Address, transactionHash?: string): Observable<Transaction>;
    /**
     * Returns an observable stream of Transaction for a specific address.
     * Each time a transaction is in unconfirmed state an it involves the address,
     * it emits a new Transaction in the event stream.
     *
     * @param address address we listen when a transaction is in unconfirmed state
     * @param transactionHash transactionHash for filtering multiple transactions
     * @return an observable stream of Transaction with state unconfirmed
     */
    unconfirmedAdded(address: Address, transactionHash?: string): Observable<Transaction>;
    /**
     * Return an observable of {@link AggregateTransaction} for specific address.
     * Each time an aggregate bonded transaction is announced,
     * it emits a new {@link AggregateTransaction} in the event stream.
     *
     * @param address address we listen when a transaction with missing signatures state
     * @param transactionHash transactionHash for filtering multiple transactions
     * @return an observable stream of AggregateTransaction with missing signatures state
     */
    aggregateBondedAdded(address: Address, transactionHash?: string): Observable<AggregateTransaction>;
    /**
     * Basic subscription for all the transactions status.
     * @param channel the transaction based channel
     * @param address the address
     * @param transactionHash the transaction hash filter.
     * @return an observable stream of Transactions
     */
    private transactionSubscription;
    /**
     * Returns an observable stream of Transaction Hashes for specific address.
     * Each time a transaction with state unconfirmed changes its state,
     * it emits a new message with the transaction hash in the event stream.
     *
     * @param address address we listen when a transaction is removed from unconfirmed state
     * @param transactionHash the transaction hash filter.
     * @return an observable stream of Strings with the transaction hash
     */
    unconfirmedRemoved(address: Address, transactionHash?: string): Observable<string>;
    /**
     * Returns an observable stream of Transaction Hashes for specific address.
     * Each time an aggregate bonded transaction is announced,
     * it emits a new message with the transaction hash in the event stream.
     *
     * @param address address we listen when a transaction is confirmed or rejected
     * @param transactionHash the transaction hash filter.
     * @return an observable stream of Strings with the transaction hash
     */
    aggregateBondedRemoved(address: Address, transactionHash?: string): Observable<string>;
    /**
     * Generic subscription for all the transaction hash based channels.
     * @param channel the channel
     * @param address the address
     * @param transactionHash the transaction hash (optional)
     * @return an observable stream of Strings with the transaction hash
     */
    private transactionHashSubscription;
    /**
     * Returns an observable stream of {@link TransactionStatusError} for specific address.
     * Each time a transaction contains an error,
     * it emits a new message with the transaction status error in the event stream.
     *
     * @param address address we listen to be notified when some error happened
     * @param transactionHash transactionHash for filtering multiple transactions
     * @return an observable stream of {@link TransactionStatusError}
     */
    status(address: Address, transactionHash?: string): Observable<TransactionStatusError>;
    /**
     * Filters the transaction by hash if provided.
     * @param transaction the transaction
     * @param transactionHash the hash.
     */
    private filterHash;
    /**
     * It filters a transaction by address using the aliases.
     *
     * This method delegates the rest loading as much as possible. It tries to filter by signer first.
     *
     * Note: this filter performs one extra rest call and it should be down in the pipeline.
     *
     * @param address the address.
     * @return an observable filter.
     */
    private filterByNotifyAccount;
    /**
     * Returns an observable stream of {@link CosignatureSignedTransaction} for specific address.
     * Each time a cosigner signs a transaction the address initialized,
     * it emits a new message with the cosignatory signed transaction in the even stream.
     *
     * @param address address we listen when a cosignatory is added to some transaction address sent
     * @return an observable stream of {@link CosignatureSignedTransaction}
     */
    cosignatureAdded(address: Address): Observable<CosignatureSignedTransaction>;
}
