"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const WebSocket = require("ws");
const Address_1 = require("../model/account/Address");
const PublicAccount_1 = require("../model/account/PublicAccount");
const NewBlock_1 = require("../model/blockchain/NewBlock");
const CosignatureSignedTransaction_1 = require("../model/transaction/CosignatureSignedTransaction");
const Deadline_1 = require("../model/transaction/Deadline");
const Transaction_1 = require("../model/transaction/Transaction");
const TransactionStatusError_1 = require("../model/transaction/TransactionStatusError");
const UInt64_1 = require("../model/UInt64");
const CreateTransactionFromDTO_1 = require("./transaction/CreateTransactionFromDTO");
var ListenerChannelName;
(function (ListenerChannelName) {
    ListenerChannelName["block"] = "block";
    ListenerChannelName["confirmedAdded"] = "confirmedAdded";
    ListenerChannelName["unconfirmedAdded"] = "unconfirmedAdded";
    ListenerChannelName["unconfirmedRemoved"] = "unconfirmedRemoved";
    ListenerChannelName["partialAdded"] = "partialAdded";
    ListenerChannelName["partialRemoved"] = "partialRemoved";
    ListenerChannelName["cosignature"] = "cosignature";
    ListenerChannelName["modifyMultisigAccount"] = "modifyMultisigAccount";
    ListenerChannelName["status"] = "status";
})(ListenerChannelName = exports.ListenerChannelName || (exports.ListenerChannelName = {}));
/**
 * Listener service
 */
class Listener {
    /**
     * Constructor
     * @param url - Listener websocket server url. default: rest-gateway's url with ''/ws'' suffix. (e.g. http://localhost:3000/ws).
     * @param namespaceRepository - NamespaceRepository interface for resolving alias.
     * @param websocketInjected - (Optional) WebSocket injected when using listeners in client.
     */
    constructor(
    /**
     * Listener websocket server url. default: rest-gateway's url with ''/ws'' suffix. (e.g. http://localhost:3000/ws)
     */
    url, 
    /**
     * Namespace repository for resolving account alias
     */
    namespaceRepository, 
    /**
     * WebSocket injected when using listeners in client.
     */
    websocketInjected) {
        this.url = url;
        this.namespaceRepository = namespaceRepository;
        this.websocketInjected = websocketInjected;
        this.url = url.replace(/\/$/, '');
        this.messageSubject = new rxjs_1.Subject();
    }
    /**
     * Open web socket connection.
     * @returns Promise<Void>
     */
    open() {
        return new Promise((resolve, reject) => {
            if (this.webSocket === undefined || this.webSocket.readyState === WebSocket.CLOSED) {
                if (this.websocketInjected) {
                    this.webSocket = new this.websocketInjected(this.url);
                }
                else {
                    this.webSocket = new WebSocket(this.url);
                }
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                this.webSocket.onopen = () => { };
                this.webSocket.onerror = (err) => {
                    reject(err);
                };
                this.webSocket.onmessage = (msg) => {
                    const message = JSON.parse(msg.data);
                    this.handleMessage(message, resolve);
                };
            }
            else {
                resolve();
            }
        });
    }
    /**
     * @internal
     *
     * This method handles one incoming message from the web socket and it dispatches it to the message subject listener.
     *
     * @param message the object payload.
     * @param resolve the method to notify when the uid has been resolved and the listener connection has been stablished.
     */
    handleMessage(message, resolve) {
        if (message.uid) {
            this.uid = message.uid;
            resolve();
        }
        else if (message.transaction) {
            this.messageSubject.next({
                channelName: message.meta.channelName,
                message: CreateTransactionFromDTO_1.CreateTransactionFromDTO(message),
            });
        }
        else if (message.block) {
            this.messageSubject.next({
                channelName: ListenerChannelName.block,
                message: this.toNewBlock(message),
            });
        }
        else if (message.code) {
            this.messageSubject.next({
                channelName: ListenerChannelName.status,
                message: new TransactionStatusError_1.TransactionStatusError(Address_1.Address.createFromEncoded(message.address), message.hash, message.code, Deadline_1.Deadline.createFromDTO(message.deadline)),
            });
        }
        else if (message.parentHash) {
            this.messageSubject.next({
                channelName: ListenerChannelName.cosignature,
                message: new CosignatureSignedTransaction_1.CosignatureSignedTransaction(message.parentHash, message.signature, message.signerPublicKey),
            });
        }
        else if (message.meta && message.meta.hash) {
            this.messageSubject.next({
                channelName: message.meta.channelName,
                message: message.meta.hash,
            });
        }
    }
    /**
     * returns a boolean that repressents the open state
     * @returns a boolean
     */
    isOpen() {
        if (this.webSocket) {
            return this.webSocket.readyState === WebSocket.OPEN;
        }
        return false;
    }
    /**
     * Close web socket connection.
     * @returns void
     */
    close() {
        if (this.webSocket && (this.webSocket.readyState === WebSocket.OPEN || this.webSocket.readyState === WebSocket.CONNECTING)) {
            this.webSocket.close();
        }
    }
    /**
     * Returns an observable stream of BlockInfo.
     * Each time a new Block is added into the blockchain,
     * it emits a new BlockInfo in the event stream.
     *
     * @return an observable stream of BlockInfo
     */
    newBlock() {
        this.subscribeTo('block');
        return this.messageSubject.asObservable().pipe(operators_1.share(), operators_1.filter((_) => _.channelName === ListenerChannelName.block), operators_1.filter((_) => _.message instanceof NewBlock_1.NewBlock), operators_1.map((_) => _.message));
    }
    /**
     * Returns an observable stream of Transaction for a specific address.
     * Each time a transaction is in confirmed state an it involves the address,
     * it emits a new Transaction in the event stream.
     *
     * @param address address we listen when a transaction is in confirmed state
     * @param transactionHash transactionHash for filtering multiple transactions
     * @return an observable stream of Transaction with state confirmed
     */
    confirmed(address, transactionHash) {
        return this.transactionSubscription(ListenerChannelName.confirmedAdded, address, transactionHash);
    }
    /**
     * Returns an observable stream of Transaction for a specific address.
     * Each time a transaction is in unconfirmed state an it involves the address,
     * it emits a new Transaction in the event stream.
     *
     * @param address address we listen when a transaction is in unconfirmed state
     * @param transactionHash transactionHash for filtering multiple transactions
     * @return an observable stream of Transaction with state unconfirmed
     */
    unconfirmedAdded(address, transactionHash) {
        return this.transactionSubscription(ListenerChannelName.unconfirmedAdded, address, transactionHash);
    }
    /**
     * Return an observable of {@link AggregateTransaction} for specific address.
     * Each time an aggregate bonded transaction is announced,
     * it emits a new {@link AggregateTransaction} in the event stream.
     *
     * @param address address we listen when a transaction with missing signatures state
     * @param transactionHash transactionHash for filtering multiple transactions
     * @return an observable stream of AggregateTransaction with missing signatures state
     */
    aggregateBondedAdded(address, transactionHash) {
        return this.transactionSubscription(ListenerChannelName.partialAdded, address, transactionHash);
    }
    /**
     * Basic subscription for all the transactions status.
     * @param channel the transaction based channel
     * @param address the address
     * @param transactionHash the transaction hash filter.
     * @return an observable stream of Transactions
     */
    transactionSubscription(channel, address, transactionHash) {
        this.subscribeTo(`${channel}/${address.plain()}`);
        return this.messageSubject.asObservable().pipe(operators_1.filter((listenerMessage) => listenerMessage.channelName === channel), operators_1.filter((listenerMessage) => listenerMessage.message instanceof Transaction_1.Transaction), operators_1.map((listenerMessage) => listenerMessage.message), operators_1.filter((transaction) => this.filterHash(transaction, transactionHash)), this.filterByNotifyAccount(address));
    }
    /**
     * Returns an observable stream of Transaction Hashes for specific address.
     * Each time a transaction with state unconfirmed changes its state,
     * it emits a new message with the transaction hash in the event stream.
     *
     * @param address address we listen when a transaction is removed from unconfirmed state
     * @param transactionHash the transaction hash filter.
     * @return an observable stream of Strings with the transaction hash
     */
    unconfirmedRemoved(address, transactionHash) {
        return this.transactionHashSubscription(ListenerChannelName.unconfirmedRemoved, address, transactionHash);
    }
    /**
     * Returns an observable stream of Transaction Hashes for specific address.
     * Each time an aggregate bonded transaction is announced,
     * it emits a new message with the transaction hash in the event stream.
     *
     * @param address address we listen when a transaction is confirmed or rejected
     * @param transactionHash the transaction hash filter.
     * @return an observable stream of Strings with the transaction hash
     */
    aggregateBondedRemoved(address, transactionHash) {
        return this.transactionHashSubscription(ListenerChannelName.partialRemoved, address, transactionHash);
    }
    /**
     * Generic subscription for all the transaction hash based channels.
     * @param channel the channel
     * @param address the address
     * @param transactionHash the transaction hash (optional)
     * @return an observable stream of Strings with the transaction hash
     */
    transactionHashSubscription(channel, address, transactionHash) {
        this.subscribeTo(`${channel}/${address.plain()}`);
        return this.messageSubject.asObservable().pipe(operators_1.filter((_) => _.channelName === channel), operators_1.filter((_) => typeof _.message === 'string'), operators_1.map((_) => _.message), operators_1.filter((_) => !transactionHash || _.toUpperCase() == transactionHash.toUpperCase()));
    }
    /**
     * Returns an observable stream of {@link TransactionStatusError} for specific address.
     * Each time a transaction contains an error,
     * it emits a new message with the transaction status error in the event stream.
     *
     * @param address address we listen to be notified when some error happened
     * @param transactionHash transactionHash for filtering multiple transactions
     * @return an observable stream of {@link TransactionStatusError}
     */
    status(address, transactionHash) {
        this.subscribeTo(`status/${address.plain()}`);
        return this.messageSubject.asObservable().pipe(operators_1.filter((_) => _.channelName === ListenerChannelName.status), operators_1.filter((_) => _.message instanceof TransactionStatusError_1.TransactionStatusError), operators_1.map((_) => _.message), operators_1.filter((_) => !transactionHash || _.hash.toUpperCase() == transactionHash.toUpperCase()), operators_1.filter((_) => address.equals(_.address)));
    }
    /**
     * Filters the transaction by hash if provided.
     * @param transaction the transaction
     * @param transactionHash the hash.
     */
    filterHash(transaction, transactionHash) {
        if (transactionHash === undefined) {
            return true;
        }
        else {
            const metaHash = transaction.transactionInfo.hash;
            return metaHash !== undefined ? metaHash.toUpperCase() === transactionHash.toUpperCase() : false;
        }
    }
    /**
     * It filters a transaction by address using the aliases.
     *
     * This method delegates the rest loading as much as possible. It tries to filter by signer first.
     *
     * Note: this filter performs one extra rest call and it should be down in the pipeline.
     *
     * @param address the address.
     * @return an observable filter.
     */
    filterByNotifyAccount(address) {
        return (transactionObservable) => {
            return transactionObservable.pipe(operators_1.flatMap((transaction) => {
                if (transaction.isSigned(address)) {
                    return rxjs_1.of(transaction);
                }
                const namespaceIdsObservable = this.namespaceRepository.getAccountsNames([address]).pipe(operators_1.map((names) => {
                    return []
                        .concat(...Array.from(names.map((accountName) => accountName.names)))
                        .map((name) => name.namespaceId);
                }));
                return namespaceIdsObservable.pipe(operators_1.filter((namespaceIds) => transaction.shouldNotifyAccount(address, namespaceIds)), operators_1.map(() => transaction));
            }));
        };
    }
    /**
     * Returns an observable stream of {@link CosignatureSignedTransaction} for specific address.
     * Each time a cosigner signs a transaction the address initialized,
     * it emits a new message with the cosignatory signed transaction in the even stream.
     *
     * @param address address we listen when a cosignatory is added to some transaction address sent
     * @return an observable stream of {@link CosignatureSignedTransaction}
     */
    cosignatureAdded(address) {
        this.subscribeTo(`cosignature/${address.plain()}`);
        return this.messageSubject.asObservable().pipe(operators_1.filter((_) => _.channelName.toUpperCase() === ListenerChannelName.cosignature.toUpperCase()), operators_1.filter((_) => _.message instanceof CosignatureSignedTransaction_1.CosignatureSignedTransaction), operators_1.map((_) => _.message));
    }
    /**
     * @internal
     * Subscribes to a channelName.
     * @param channel - Channel subscribed to.
     */
    subscribeTo(channel) {
        const subscriptionMessage = {
            uid: this.uid,
            subscribe: channel,
        };
        this.webSocket.send(JSON.stringify(subscriptionMessage));
    }
    /**
     * This method maps a BlockInfoDTO from rest to the SDK's BlockInfo model object.
     *
     * @internal
     * @param {BlockInfoDTO} dto the dto object from rest.
     * @returns {NewBlock} a BlockInfo model
     */
    toNewBlock(dto) {
        const networkType = dto.block.network.valueOf();
        return new NewBlock_1.NewBlock(dto.meta.hash, dto.meta.generationHash, dto.block.signature, PublicAccount_1.PublicAccount.createFromPublicKey(dto.block.signerPublicKey, networkType), networkType, dto.block.version, dto.block.type, UInt64_1.UInt64.fromNumericString(dto.block.height), UInt64_1.UInt64.fromNumericString(dto.block.timestamp), UInt64_1.UInt64.fromNumericString(dto.block.difficulty), dto.block.feeMultiplier, dto.block.previousBlockHash, dto.block.transactionsHash, dto.block.receiptsHash, dto.block.stateHash, dto.block.proofGamma, dto.block.proofScalar, dto.block.proofVerificationHash, dto.block.beneficiaryAddress ? Address_1.Address.createFromEncoded(dto.block.beneficiaryAddress) : undefined);
    }
}
exports.Listener = Listener;
//# sourceMappingURL=Listener.js.map