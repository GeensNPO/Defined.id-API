"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountStateBuilder = void 0;
const AccountKeyTypeFlagsDto_1 = require("./AccountKeyTypeFlagsDto");
const AccountStateFormatDto_1 = require("./AccountStateFormatDto");
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const HeightActivityBucketsBuilder_1 = require("./HeightActivityBucketsBuilder");
const HeightDto_1 = require("./HeightDto");
const ImportanceSnapshotBuilder_1 = require("./ImportanceSnapshotBuilder");
const KeyDto_1 = require("./KeyDto");
const MosaicBuilder_1 = require("./MosaicBuilder");
const PinnedVotingKeyBuilder_1 = require("./PinnedVotingKeyBuilder");
class AccountStateBuilder {
    constructor(address, addressHeight, publicKey, publicKeyHeight, accountType, supplementalPublicKeysMask, votingPublicKeys, balances, linkedPublicKey, nodePublicKey, vrfPublicKey, importanceSnapshots, activityBuckets) {
        this.address = address;
        this.addressHeight = addressHeight;
        this.publicKey = publicKey;
        this.publicKeyHeight = publicKeyHeight;
        this.accountType = accountType;
        this.supplementalPublicKeysMask = supplementalPublicKeysMask;
        this.linkedPublicKey = linkedPublicKey;
        this.nodePublicKey = nodePublicKey;
        this.vrfPublicKey = vrfPublicKey;
        this.votingPublicKeys = votingPublicKeys;
        this.importanceSnapshots = importanceSnapshots;
        this.activityBuckets = activityBuckets;
        this.balances = balances;
        if (importanceSnapshots) {
            this.format = AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE;
        }
        else {
            this.format = AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE;
        }
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const address = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, address.getSize());
        const addressHeight = HeightDto_1.HeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, addressHeight.getSize());
        const publicKey = KeyDto_1.KeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, publicKey.getSize());
        const publicKeyHeight = HeightDto_1.HeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, publicKeyHeight.getSize());
        const accountType = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const format = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const supplementalPublicKeysMask = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const votingPublicKeysCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const supplementalPublicKeysMaskConditionBytes = Uint8Array.from(byteArray.slice(0, 32));
        byteArray.splice(0, 32);
        const votingPublicKeys = [];
        for (let i = 0; i < (Array.isArray(votingPublicKeysCount) ? GeneratorUtils_1.GeneratorUtils.compact(votingPublicKeysCount) : votingPublicKeysCount); i++) {
            const item = PinnedVotingKeyBuilder_1.PinnedVotingKeyBuilder.loadFromBinary(Uint8Array.from(byteArray));
            votingPublicKeys.push(item);
            byteArray.splice(0, item.getSize());
        }
        const formatConditionBytes = Uint8Array.from(byteArray.slice(0, 1));
        byteArray.splice(0, 1);
        const balancesCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const balances = [];
        for (let i = 0; i < (Array.isArray(balancesCount) ? GeneratorUtils_1.GeneratorUtils.compact(balancesCount) : balancesCount); i++) {
            const item = MosaicBuilder_1.MosaicBuilder.loadFromBinary(Uint8Array.from(byteArray));
            balances.push(item);
            byteArray.splice(0, item.getSize());
        }
        let linkedPublicKey;
        if (supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.LINKED) {
            linkedPublicKey = KeyDto_1.KeyDto.loadFromBinary(supplementalPublicKeysMaskConditionBytes);
        }
        let nodePublicKey;
        if (supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.NODE) {
            nodePublicKey = KeyDto_1.KeyDto.loadFromBinary(supplementalPublicKeysMaskConditionBytes);
        }
        let vrfPublicKey;
        if (supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.VRF) {
            vrfPublicKey = KeyDto_1.KeyDto.loadFromBinary(supplementalPublicKeysMaskConditionBytes);
        }
        let importanceSnapshots;
        if (format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            importanceSnapshots = ImportanceSnapshotBuilder_1.ImportanceSnapshotBuilder.loadFromBinary(formatConditionBytes);
        }
        let activityBuckets;
        if (format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            activityBuckets = HeightActivityBucketsBuilder_1.HeightActivityBucketsBuilder.loadFromBinary(formatConditionBytes);
        }
        return new AccountStateBuilder(address, addressHeight, publicKey, publicKeyHeight, accountType, supplementalPublicKeysMask, votingPublicKeys, balances, linkedPublicKey, nodePublicKey, vrfPublicKey, importanceSnapshots, activityBuckets);
    }
    getAddress() {
        return this.address;
    }
    getAddressHeight() {
        return this.addressHeight;
    }
    getPublicKey() {
        return this.publicKey;
    }
    getPublicKeyHeight() {
        return this.publicKeyHeight;
    }
    getAccountType() {
        return this.accountType;
    }
    getFormat() {
        return this.format;
    }
    getSupplementalPublicKeysMask() {
        return this.supplementalPublicKeysMask;
    }
    getLinkedPublicKey() {
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.LINKED) {
            throw new Error('supplementalPublicKeysMask is not set to LINKED.');
        }
        return this.linkedPublicKey;
    }
    getNodePublicKey() {
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.NODE) {
            throw new Error('supplementalPublicKeysMask is not set to NODE.');
        }
        return this.nodePublicKey;
    }
    getVrfPublicKey() {
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.VRF) {
            throw new Error('supplementalPublicKeysMask is not set to VRF.');
        }
        return this.vrfPublicKey;
    }
    getVotingPublicKeys() {
        return this.votingPublicKeys;
    }
    getImportanceSnapshots() {
        if (this.format !== AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            throw new Error('format is not set to HIGH_VALUE.');
        }
        return this.importanceSnapshots;
    }
    getActivityBuckets() {
        if (this.format !== AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            throw new Error('format is not set to HIGH_VALUE.');
        }
        return this.activityBuckets;
    }
    getBalances() {
        return this.balances;
    }
    getSize() {
        let size = 0;
        size += this.address.getSize();
        size += this.addressHeight.getSize();
        size += this.publicKey.getSize();
        size += this.publicKeyHeight.getSize();
        size += 1;
        size += 1;
        size += 1;
        size += 1;
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.LINKED) {
            size += this.linkedPublicKey.getSize();
        }
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.NODE) {
            size += this.nodePublicKey.getSize();
        }
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.VRF) {
            size += this.vrfPublicKey.getSize();
        }
        this.votingPublicKeys.forEach((o) => size += o.getSize());
        if (this.format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            size += this.importanceSnapshots.getSize();
        }
        if (this.format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            size += this.activityBuckets.getSize();
        }
        size += 2;
        this.balances.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const addressBytes = this.address.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressBytes);
        const addressHeightBytes = this.addressHeight.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressHeightBytes);
        const publicKeyBytes = this.publicKey.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, publicKeyBytes);
        const publicKeyHeightBytes = this.publicKeyHeight.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, publicKeyHeightBytes);
        const accountTypeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.accountType, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountTypeBytes);
        const formatBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.format, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, formatBytes);
        const supplementalPublicKeysMaskBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getSupplementalPublicKeysMask(), 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, supplementalPublicKeysMaskBytes);
        const votingPublicKeysCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.votingPublicKeys.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, votingPublicKeysCountBytes);
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.LINKED) {
            const linkedPublicKeyBytes = this.linkedPublicKey.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, linkedPublicKeyBytes);
        }
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.NODE) {
            const nodePublicKeyBytes = this.nodePublicKey.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, nodePublicKeyBytes);
        }
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.VRF) {
            const vrfPublicKeyBytes = this.vrfPublicKey.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, vrfPublicKeyBytes);
        }
        this.votingPublicKeys.forEach((item) => {
            const votingPublicKeysBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, votingPublicKeysBytes);
        });
        if (this.format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            const importanceSnapshotsBytes = this.importanceSnapshots.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, importanceSnapshotsBytes);
        }
        if (this.format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            const activityBucketsBytes = this.activityBuckets.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, activityBucketsBytes);
        }
        const balancesCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.balances.length, 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, balancesCountBytes);
        this.balances.forEach((item) => {
            const balancesBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, balancesBytes);
        });
        return newArray;
    }
}
exports.AccountStateBuilder = AccountStateBuilder;
//# sourceMappingURL=AccountStateBuilder.js.map